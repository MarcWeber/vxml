{-# OPTIONS_GHC -fcontext-stack=100 #-}
{-# LANGUAGE NoMonomorphismRestriction,  PatternSignatures, ScopedTypeVariables, EmptyDataDecls,
    FunctionalDependencies, FlexibleInstances, FlexibleContexts,
    MultiParamTypeClasses, UndecidableInstances #-}

{- see cabal file
#ifndef TypeToNatTypeEq
  {-# Language OverlappingInstances  #-}
#endif
-}

module Text.XML.Validated.Types (
  -- your interface: (memomic: trailing T for with phantom _T_ypes or _t_yped)
    CreateElT(..) -- createElT: use the functions generated by template haskell instead called "tagname"
  , AddAttrT(..)  -- addAttrT: use the function generation by template haskell instead called "attrname_A"
  , (<<) -- may change
  , AddElT(..)    -- addElT: add sub element. alias (<<)
  , (<<<) --  may change
  , AddTextT(..)  -- addTextT: add PCDATA to element. alias (<<<)
  , EndElT(..)
  -- , XmlDocT(..) -- use xml instead
  , xml    -- validate, return result type of root element with doctype
  , fromPT -- validate, return resulty type of any non root element
  , text -- flip addTextT

  -- implementation for different result types:
  -- see example in Instances
  , CreateEl(..)
  , AddAttribute(..)
  , EndAttrs(..)
  , EndAttrsEndElement(..)
  , AddEl(..)
  , AddText(..)
  , EndEl(..)
  , XmlDoc(..)
  , XmlIds(..)


  -- exported for utils and TH, you should not have to use them
  , Element, AS, AttrOk
#ifdef DoValidate
  , ANY, C, PCDATA, A, ElEndable
#else
  , NoValidation
#endif
  , EMPTY

  , InitialState(..)
  , PT, NYV, Elem
#ifdef TypeToNatTypeEq
  , TypeToNat
#endif

  , XmlIdsFromRoot(..)
  -- for debugging
  , debugEl
#ifdef DoValidate
  , Consume
#endif
  ) where

import Data.HList
import Data.Either

{- design notes
   ============================================================================

   the element validation state which keeps information about which attributes
   and elements may still be added is either

   NYV ( -- NYV = not yet valid
        Element
          elType          -- the eltype (Html_T or Body_T ..)
          stateAttributes  -- see Consume for a list of valid content
          stateChilds     -- (AS required added) all three beeing a HList of (A attrtype)
          hasChildren     -- HTrue or HFalse
       )

   or

   Valid ( elType )

  The life cycle of the state is typically:
  -----------------------------------------

  NYV ( Element elType stA st HFalse )

  -- addAttrT: add some attributes adding the attributes to the added list and removing
  -- them from the required list
  NYV ( Element elType stA' st HFalse )

  -- addElT: add one element, Consume will determine the new state,
  -- fail if the child (elment or PCDATA) may not be added attribute validation
  -- takes here or if no child is added in endElT
  NYV ( Element elType stA' st' HTrue )

  --  endElT: validate children state
  Valid elType

  For elements without childs the shortcut EndAttrsEndElement will be used to
  allow easy generation of empty <img .../> text instead of <img ...></img>


  Generation of the result type:
  -----------------------------------------
  Each time when one of createElT, addAttrT, endElT is called a corresponding
  function is called to create the result type. The reference implementation
  will result in a ready to use XML-String. See Instances / *.hs

  That's why an element has the type PT (state resultType)

  It should be sufficiently easy to implement returning kind of tree
  representation as well.

-}



-- see also xml
fromPT targetV = fromPT' targetV . endElT

-- fromPT': take result type before final validation (done in endElT), internal
-- use only
fromPT' :: (PT st el) -> el
fromPT' (PT _ v) = v

-- xml is alias for xmlDocT. xmlDocT is the same as fromPT but it also adds the
-- doc type declaration
xml = xmlDocT
(<<) = addElT
(<<<) = addTextT
text :: ( AddTextT el el2 text elst elst2
        , AddText el2 String
        ) => text -> PT elst el -> PT elst2 el2
text = flip addTextT

-- ========== classes to generate the result type ====================
-- mainly targeting kind of String output (see Instances/ * )

data XmlIds = XmlIds {
  publicId :: Maybe String
  , systemId :: Maybe String
  }

class CreateEl elType el where
  createEl :: elType -> el

class AddAttribute el attrType where
  addAttribute :: el -> attrType -> String -> el -- String = attr value FIXME: extend to all attr types - still proof of concept

-- after this no attributes can be allowed
class EndAttrs el el2 | el -> el2, el2 -> el where
  endAttrs :: el -> el2
class AddEl el elc | el -> elc, elc -> el
    -- el -> elc: from a not finalized element can a finalized be deduced (maybe not necessary)
    -- elc -> el so that you can just give the end type and the types before will be infered automatically
  where
  addEl :: el -> elc -> el -- el, child

{- quote from XML spec:
  Empty-element tags may be used for any element which has no content, whether or
  not it is declared using the keyword EMPTY. For interoperability, the
  empty-element tag SHOULD be used, and SHOULD only be used, for elements which
  are declared EMPTY
-}
class EndAttrsEndElement elType el elFinal | el -> elFinal, elFinal -> el where
  endAttrsEndElement, endAttrsEndElementDeclaredEmpty :: elType -> el -> elFinal
  endAttrsEndElementDeclaredEmpty _ = endAttrsEndElement (undefined :: elType)
  endAttrsEndElement _ = endAttrsEndElementDeclaredEmpty (undefined :: elType)

class AddText el text where
  addText :: el -> text -> el -- el, text node

-- after this no attributes can be allowed
class EndEl elType el elFinal | el -> elFinal, elFinal -> el where
  endEl :: elType -> el -> elFinal

class XmlDoc rootElType el el' | el -> el', el' -> el where
  xmlDoc :: rootElType -> XmlIds -> el -> el'

-- ========== typed classes ==========================================

class XmlIdsFromRoot rootElType where
  xmlIds :: rootElType -> XmlIds -- public, system id

class XmlDocT elst el doc |  doc -> el, el -> doc where
  xmlDocT :: (PT elst el) -> doc

-- instance ended root element
instance ( XmlDoc rootElType el doc
        , XmlIdsFromRoot rootElType
        ) => XmlDocT (Valid rootElType) el doc where
  xmlDocT (PT _ e) = xmlDoc (undefined :: rootElType) (xmlIds (undefined :: rootElType)) e
-- instance not yet ended root elemnt
instance ( EndElT (NYV (Element elType stA st hchs)) st' el el2
        , XmlDocT st' el2 doc
        ) => XmlDocT (NYV (Element elType stA st hchs)) el doc where
  xmlDocT = xmlDocT . endElT


data PT a b = PT a b -- phantom type containing state a and the result b

class InitialState elType initialState | elType -> initialState
  where
  initialState :: elType -> initialState
  initialState = undefined

class ( InitialState elType initialState -- default instance, no need to write your own
      , CreateEl elType el
      ) => CreateElT elType initialState el
      | elType -> initialState where -- el ready to append attributes
  createElT :: elType -> PT initialState el
  createElT _  = PT (initialState (undefined :: elType))
                     (createEl (undefined :: elType))

instance (
      CreateEl elType el
    , InitialState elType initialState
    ) => CreateElT elType initialState el

class AttrOk elType attr
class AddAttrT attrType st st2 el
      | st attrType -> st2 where
  addAttrT :: PT st el -> attrType -> String -> PT st2 el
  -- String = attr value FIXME: extend to all attr types - still proof of concept

instance (
        AddAttribute el attrType
      , AttrOk elType attrType
#ifdef DoValidate
      , -- remove attribute from required list
        HMemberM (A attrType) req mreq
      , HFromMaybe mreq req req'
      , -- no attribute may be added twice
        HMember (A attrType) added rd
      , CheckDuplicateAttribute elType attrType rd
#else
      , IdClass req req'
#endif
      ) => AddAttrT attrType (NYV (Element elType (AS req  added) st HFalse))
                             (NYV (Element elType (AS HNil (HCons (A attrType) added)) st HFalse)) el


  where
  addAttrT (PT _ t) _ v = PT (undefined :: st2)
                          (addAttribute t (undefined :: attrType) v)
     -- fail nicer error messages
instance ( YouCantAddAttributesAfterAddingContentTo elType
      ) => AddAttrT attrType (NYV (Element elType stA st HTrue)) st2 el
  where addAttrT = undefined -- shut up warning


#ifdef DoValidate

class HFromMaybe mb b r | mb b -> r
instance  HFromMaybe HNothing b b
instance  HFromMaybe (HJust a) b a
class CheckDuplicateAttribute elType attrType hbool
instance CheckDuplicateAttribute elType attrType HFalse
instance ( DuplicateAttribute elType attrType
         ) => CheckDuplicateAttribute elType attrType HTrue

#endif

-- ========== type level implementation ==============================

-- ========== adding sub elements (tags) =============================
class AddElT est est' el el2 stc elc
    | el -> el2, el2 -> el, est -> est' where
  addElT :: PT est el -> PT stc elc -> PT est' el2
-- first child ? (then endAttrs must be called)
instance (
    EndAttrs el el2
  , AddEl el2 elc
#ifdef DoValidate
  , Consume st (Elem celType) st'
#else
  , IdClass st st'
#endif
  ) => AddElT (NYV (Element elType stA st HFalse)) (NYV (Element elType stA st' HTrue)) el el2
              (Valid celType) elc where
 addElT (PT _ t) (PT _ c) = PT (undefined :: est') $ addEl (endAttrs t) c
-- not first child
instance (
    AddEl el elc
#ifdef DoValidate
  , Consume st (Elem celType) st'
#else
  , IdClass st st'
#endif
  ) => AddElT (NYV (Element elType stA st HTrue)) (NYV (Element elType stA st' HTrue)) el el
              (Valid celType) elc where
 addElT (PT _ t) (PT _ c)= PT (undefined :: est') $ addEl t c
-- validate child
instance (
    AddEl el elc'
#ifdef DoValidate
  , Consume st (Elem celType) st'
#else
  , IdClass st st'
#endif
  , EndElT (NYV (Element celType cstA cst chchs)) (Valid celType) elc elc'
  , AddElT (NYV (Element elType  stA st hchs)) (NYV (Element elType stA st' HTrue)) el el
           (Valid celType) elc'
  ) => AddElT (NYV (Element elType  stA st hchs)) (NYV (Element elType stA st' HTrue)) el el
              (NYV (Element celType cstA     cst   chchs)) elc where
 addElT el childEl = addElT el $ endElT childEl

-- ========== adding sub elements (text) =============================
class AddTextT el el2 text elst elst2 | el -> el2, el2 -> el, elst -> elst2 where
  addTextT :: PT elst el -> text -> PT elst2 el2
-- first child
instance (
    EndAttrs el el2
#ifdef DoValidate
  , StEndAttrs elType stA
#endif
  , AddText el2 text
#ifdef DoValidate
  , Consume st PCDATA st'
#else
  , IdClass st st'
#endif
  ) => AddTextT el el2 text (NYV (Element elType stA st  HFalse))
                            (NYV (Element elType stA st' HTrue))
  where
  addTextT (PT _ t) text = PT undefined $ addText (endAttrs t) text
-- not first child
instance (
    AddText el text
#ifdef DoValidate
  , Consume st PCDATA st'
#else
  , IdClass st st'
#endif
  ) => AddTextT el el text (NYV (Element elType stA st  HTrue))
                           (NYV (Element elType stA st' HTrue))
  where
  addTextT (PT _ t) text = PT undefined $ addText t text

-- ========== final element check ====================================
class EndElT st st' el el2| st -> st', el -> el2, el2 -> el where
    endElT :: (PT st el)
           -> (PT st' el2)
-- end element with childs
instance ( EndEl elType el el2
#ifdef DoValidate
         , ElEndable elType st
#endif
         ) => EndElT (NYV (Element elType stA st HTrue))
                     (Valid elType) el el2
  where endElT (PT _ el) = PT undefined (endEl (undefined :: elType)  el)
-- end elements without childs declared EMPTY
instance ( EndAttrsEndElement elType el el2
#ifdef DoValidate
         , StEndAttrs elType stA
#endif
         ) => EndElT (NYV (Element elType stA EMPTY HFalse))
                     (Valid elType) el el2
  where endElT (PT _ el) = PT undefined (endAttrsEndElementDeclaredEmpty (undefined :: elType) el)
-- end elements without childs not declared EMPTY
#ifdef DoValidate
instance ( EndAttrsEndElement elType el el2
         , StEndAttrs elType stA
         , ElEndable elType st
         ) => EndElT (NYV (Element elType stA st HFalse))
                     (Valid elType) el el2
  where endElT (PT _ el) = PT undefined (endAttrsEndElement (undefined :: elType) el)
#else
instance ( EndAttrsEndElement elType el el2
         ) => EndElT (NYV (Element elType stA NoValidation HFalse))
                     (Valid elType) el el2
  where endElT (PT _ el) = PT undefined (endAttrsEndElement (undefined :: elType) el)
#endif

-- ========== the uglier part, the validation by transforming states

-- ========== elements and subelements / consume classes =============

-- element content accept stuff
data Element elType stAttributes elementsState hasChilds
data AS req added -- attribute state
-- elType: the element type_T
-- hasChilds: HTrue or HFalse, is necessary to to know wether empty tags <br/> can be used

-- ========== allowed to end element ? ===============================
#ifdef DoValidate
class ElEndable elType a
instance ElEndable elType C
instance ElEndable elType EMPTY
instance ElEndable elType ANY
instance ElEndable elType PCDATA
  -- fail nicer error messages
instance ( MoreElementsExpected elType (Elem a)) =>  ElEndable elType (Elem a)

class StEndAttrs elType elst
instance  StEndAttrs elType (AS HNil added)
  -- fail nicer error messages
instance  ( RequiredAttributesMissing elType (HCons a b)
          ) => StEndAttrs elType (AS (HCons a b) added)
#endif

data EMPTY         -- see comment on EndAttrsEndElement
data ANY           -- any element
data Elem elType   -- match an element
data A a
data PCDATA        -- add text
data NYV state -- not yet valid state
data Valid elType -- "state" of validated element
#ifdef DoValidate
data C      -- consumed, no element left
data F a    --

class Consume st el r | st el -> r -- result is on of C,CS,R,F

-- PCDATA
instance Consume PCDATA PCDATA C
instance Consume ANY PCDATA C
instance Consume ANY (Elem e) C
-- fail nicer error messages
instance (Fail (GotPCDATAButExpected (Elem e))
        ) => Consume (Elem e) PCDATA ()

instance (Fail (ExpectedPCDATABUtGot (Elem e))
        ) => Consume PCDATA (Elem e) ()

#endif

-- ========== errors =================================================
data GotPCDATAButExpected a
data ExpectedPCDATABUtGot a

-- never implement instances for these.. either the lib is buggy or your data
-- does'nt validate against dtd
class MoreElementsExpected elType a
class RequiredAttributesMissing elType req
class YouCantAddAttributesAfterAddingContentTo elType
class DuplicateAttribute elType attrType
-- class Fail (from HList)
debugEl :: (Fail x) => (PT x String) -> b
debugEl = undefined

--  ========= type level equality helper =============================
instance ( TypeEq a b r) => HEq (A a) (A b) r

class TypeCast   a b   | a -> b, b->a   where typeCast   :: a -> b
class TypeCast'  t a b | t a -> b, t b -> a where typeCast'  :: t->a->b
class TypeCast'' t a b | t a -> b, t b -> a where typeCast'' :: t->a->b
instance TypeCast'  () a b => TypeCast a b where typeCast x = typeCast' () x
instance TypeCast'' t a b => TypeCast' t a b where typeCast' = typeCast''
instance TypeCast'' () a a where typeCast'' _ x  = x

instance (HBool b, TypeCast HFalse b
          ) => TypeEq x y b
instance TypeEq x x HTrue
#ifndef DoValidate
class IdClass a b | a -> b
instance IdClass  a a
data NoValidation
#endif
